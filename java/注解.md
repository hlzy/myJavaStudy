# 注解(Annotation)和反射(Reflection)

### 一 注解入门

* JDK5.0引入技术
  * 不是程序本身，可以对程序做出解释
* 可以被其他程序(如：编译器)读取
* 格式是“@注释名”还可以添加一些参数如 @SuppressWarnings(value="unchecked")
* 可以在package,class,method,field上添加 ，相当于添加了额外辅助信息，可以通过**反射编程**实现对元数据的访问。

### 二 内助注解

* Override 定义在java.lang.Override
* Deprecated 定义在java.lang.Deprecated
* SuppressWarnings

### 三 元注解

元注解的作用就是负责注解其他的注解，Java4个标注的meta-annotitaion，用于对其他注解的说明，均在java.lang.annotation包中可以找到，

* @Target: 描述使用的范围如（使用在类，方法，构造器上）

* @Retention：什么级别保存该注释信息，用于描述注注解生命周期

  > SOURCE < CLASS < RUNTIME（在运行时有用）

* @Documented 表示是否讲注解生成到Javadoc中

* @Inherited @Inherited 子类可以继承父类注解

### 四 自定义注解

使用@interface自定义注解是，自动继承java.lang.annotation.Annotation接口

* 格式 public @interface 注解名{定义内容}
* 每一个方法都是配置参数
  * 方法的名称就是参数的名称
  * 返回类型就是参数的类型（返回值只能是基本类型Class,String,enum）
  * default申明默认值
  * 如果只有一个参数一般名称是value

e.g.

```java
public class Demo3 {
    @MyAnnotation2()
    public void test(){

    }
}

@Target(value = {ElementType.METHOD,ElementType.TYPE})
@Retention(value = RetentionPolicy.RUNTIME)
@interface MyAnnotation2{
    //注解参数:
    String name() default "";
    int age() default 0;
    int id() default -1;
    String[] schools() default {"清华"};
}
```

### 五 反射机制(java.Reflection)

#### 静态和动态语言

**动态语言**：在运行时代码可以根据某些调整改变自身机构,如python,javascript,object-c,PHP

**静态语言**：在运行时结构不能变如：java ,c++

Java不是动态语言，但java可以称为"准动态语言"，通过反射机制可以使JAVA获取一定的动态性。Java的动态性可以让编程更加灵活。

#### 反射机制概述

Reflection 反射机制运行程序在执行期间借助Reflection API获取任何类的内部信息（类名，属性，方法，private），并内直接操作任意内部属性及方法。  

 正常方法：

引入需要的“包类”名称 -> 通过new实例化 -> 取得实例化对象

反射方法：

实例化对象-> getClass()方法->得到完整的“包类”名称

* Class本身也是一个类
* Class对象只能由系统建立对象
* 一个加载的类在JVM中只会有一个Class实例
* 一个Class对象对应的是一个加载到JVM中的一个class文件
* 每个实例都会知道自己是由于class生成的。
* class类是Reflection的根源，针对任何你想动态加载，运行的类，唯有先获得对应的class对象。

#### 理解class类并获取class实例

获取的4个方式

* 通过实例化的getClass方法
* 通过Class.forName
* 直接通过类

```java
//forname方法        
		Class c1 = Class.forName("helian.annotation.User");
        System.out.println(c2.hashCode());
        User u1 = new User(1,"he",2);
//getClass方法
        Class c5 = u1.getClass();
        System.out.println(c5.hashCode());
//类名class属性获取
        System.out.println(User.class.hashCode());
//获取父类方法
        System.out.println(c5.getSuperclass());
```

#### 类的加载与ClassLoader

##### Java内存分析：

* 堆：
  * 存放所有new对象和数组
  * 可以被所有线程共享，不会存放别的对象引用
* 栈：
  * 存放基本变量类型（包含基本类型的具体数值）
  * 引用对象的变量（存放引用在堆里面的具体地址）
  * 栈不能被线程共享
* 方法区：
  * 属于堆的一种
  * 可以被线程共享
  * 包含了所有的class和static变量

##### 类的加载

1. 类的加载

将类的class文件读入内存，并为之创建一个java.lang.Class对象

2. 类的链接：将类的二进制数据合并到JVM中

   1. 验证：加载的类信息是否符JVM规范，有没有安全方面问题
   2. 准备:  为类变量static分配内存并设置类变量默认初始值，这些内存都在方法区中进行分配。
   3. 解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程。

3. 类的初始化：JVM负责堆类的初始化。

   执行类构造器<clinit>()方法的过程，类构造器方法由编译器自动收集类中**所有变量的赋值动作和静态代码块**中的语句合并产生。

```java
public class Demo6 {
    public static void main(String[] args) {
        /*
        l. 类的加载，产生类对应的class对象
        2. 链接： 结束后m=0
        3. 初始化:
         <client> () {
        System.out.println("A静态代码块初始化");
        m = 300;
        m = 100;
        System.out.println("AXA匿名代码块初始化");
        m = 500;
        System.out.println("A无参构造初始化:" + m);
         }
         */
        A a =new A();
        System.out.println(A.m);
    }
}
class A{
    {
        System.out.println("AXA匿名代码块初始化");
        m = 500;
    }
    static int m = 100;
    static {
        System.out.println("A静态代码块初始化");
        m = 300;
    }
    public A(){
        System.out.println("A无参构造初始化:" + m);
    }
}
```

##### 什么时候会发生类的初始化？

1. 类的主动引用(一定会发生类的初始化)
   * 当虚拟机启动，main方法所在的类。
   * new。
   * 当初始化一个类，如果父类没有被初始化，则会先初始化它的父类。
2. 类的被动引用(不会发送类的初始化)
   1. 通过子类引用父类的静态变量，不会导致子类初始化（因为静态变量再链接阶段完成再初始化之前）
   2. 通过数组定义类引用不会触发类的初始化

##### 类加载器

类加载器时用于把类（class）编写的，JVM定义了如下类型的加载器。

1. 将class文件字节码加入内存中，并将这些静态数据转换成方法区的运行时的数据结构，然后再堆中生成一个代表这个类的java.lang.class对象，用作方法区的访问入口
2. 缓存类一旦被加载到类加载器中，维持一段那时间，不通过GC回收Class对象。

![image-20200915000739381](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200915000739381.png)

![image-20200915002932367](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200915002932367.png)

#### 创建运行时的类的对象

#### 获取运行时类的完整结构

```java
public class Demo9 {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException {
        Class c1 = Class.forName("helian.annotation.User");

        System.out.println(c1.getName());
        System.out.println(c1.getSimpleName());

        System.out.println("===========");
        Field[] fileds =  c1.getFields();
        for (Field field :fileds){
            System.out.println(field);
        }
        System.out.println("===========");
        Field[] fileds2 =  c1.getDeclaredFields();
        for (Field field :fileds2){
            System.out.println(field);
        }
        Field name = c1.getDeclaredField("name");
        System.out.println(name);

        //获取类的方法
        System.out.println("====获取类的public方法(获取父类的)=======");
        Method[] methods = c1.getMethods();
        for (Method method:methods){
            System.out.println(method);
        }

        System.out.println("====获取本类的全部方法(不获取父类)=======");
        Method[] methods2 = c1.getDeclaredMethods();
        for (Method method:methods2){
            System.out.println(method);
        }

        System.out.println("====从名称获取方法=======");
        //传入参数时为了防止重载
        Method getName =  c1.getMethod("getName",null);
        Method setName =  c1.getMethod("setName",String.class);

        System.out.println(getName);
        System.out.println(setName);

        //获得指定构造器
        System.out.println("============");
        Constructor[] constructors = c1.getConstructors();
        for(Constructor constructor:constructors){
            System.out.println(constructor);
        }
        System.out.println("============");
        Constructor[] constructors2 = c1.getDeclaredConstructors();
        for(Constructor constructor:constructors2){
            System.out.println(constructor);
        }
    }
}
```



#### 调用运行时类的执行结构

### 六 反射操作注解

```Java
public class Demo12 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class c1 = Class.forName("helian.annotation.Student2");
//        Annotation[] annos =  c1.getAnnotations();
//        for(Annotation anno:annos){
//            System.out.println(anno);
//        }
//        System.out.println("=================");
//        Annotation[] annosx2 = c1.getDeclaredAnnotations();
//        for(Annotation anno:annosx2){
//            System.out.println(anno);
//        }
        System.out.println("=================");
        Field[] fields = c1.getDeclaredFields();
        for(Field x:fields){
            System.out.println("****************");
            System.out.println(x);
            Annotation[] filed_annos =  x.getAnnotations();
            for(Annotation y:filed_annos){
                FieldAnno f = (FieldAnno) y;
                System.out.println(((FieldAnno) y).columnName()+"---"+((FieldAnno) y).type());
            }
        }
    }
}

@ClassAnno("helian")
class Student2{
    @FieldAnno(columnName = "id",type = "string",length = 10)
    private int id;
    @FieldAnno(columnName = "age",type = "int",length = 10)
    private int age;
    @FieldAnno(columnName = "name",type = "string",length = 10)
    private String name;

    @MethodAnno(methodName = "construct",type = "int")
    public Student2(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }


    public Student2() {
    }

    @MethodAnno(methodName = "getId",type = "int")
    public int getId() {
        return id;
    }

    @MethodAnno(methodName = "setId",type = "int")
    public void setId(int id) {
        this.id = id;
    }
    
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}


//类名注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface ClassAnno{
    String value();
}

//属性的注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface FieldAnno{
    String columnName();
    String type();
    int length();
}

//方法的注解
@Target({ElementType.METHOD , ElementType.CONSTRUCTOR})
@Retention(RetentionPolicy.RUNTIME)
@interface MethodAnno{
    String methodName();
    String type();
}

```



### 七 尚未解决的问题：

1. 如Override的注解是如何实现的。