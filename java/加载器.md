# Java类加载器详细分析

## 1. 什么是类加载器

### 1.1  *定义：*

* **Java类加载器（**Java Classloader）是Java运行时环境（Java Runtime Environment）的一部分，负责[动态加载](https://baike.baidu.com/item/动态加载)Java类到[Java虚拟机](https://baike.baidu.com/item/Java虚拟机)的内存空间中。
* 类通常是按需加载，即第一次使用该类时才加载。
* 使用类加载器，Java运行时系统不需要知道文件与文件系统。
* 学习类加载器时，掌握***Java的委派概***念很重要。
* 每个Java类必须由某个类加载器装入内存中。

### 1.2  JVM默认三个类加载器

1. 引导（Bootstrap）类加载器。由原生代码（如C语言）编写，不继承自java.lang.ClassLoader。***负责加载核心Java库***，存储在<JAVA_HOME>/jre/lib目录中。
2. 扩展（Extensions）类加载器。用来在<JAVA_HOME>/jre/lib/ext,或java.ext.dirs中指明的目录中加载 Java的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。该类由sun.misc.Launcher$ExtClassLoader实现。
3. Apps类加载器（也称系统类加载器）。根据 Java应用程序的类路径（java.class.path或CLASSPATH环境变量）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ***ClassLoader.getSystemClassLoader()***来获取它。该类由***sun.misc.Launcher$AppClassLoader***实现。

```java
public class ClassLoaderTest {
    public static void main(String[] args) {
//      自建的类使用的AppClassLoader
        System.out.println(new ClassLoaderTest().getClass().getClassLoader());
        ClassLoader loader = new ClassLoaderTest().getClass().getClassLoader();
//jdk.internal.loader.ClassLoaders$PlatformClassLoader@1b28cdfa
        System.out.println(loader.getParent());
//        null
        System.out.println(loader.getParent().getParent());
//正常执行可以完成loader的工作
        Class  c1 = loader.loadClass("com.lian.file.User");
//无法Load由于父类是扩展加载器，主要是在Java扩展库中搜索
        Class c1 = loader.getParent().loadClass("com.lian.file.User");
    }
}
```

![类加载器树状组织结构示意图](https://developer.ibm.com/developer/default/articles/j-lo-classloader/images/image001.jpg)

## 2. 如何使用类加载器

### 2.1 使用代码

如上代码

### 2.2 使用的场景

* 加密，由于java容易被反编译，可以吧自己的代码进行加密，然后使用自定义的类加载器对其还原加载
* 从非标准的来加载代码，如果使用部分字节码来源于数据库或者网络，就可以自己写个类加载器，从指定来源加载类
* 动态创建

## 3.类加载器如何实现

实现自定义类加载器 需要继承Classloader,

```java
public class FileSystemClassLoader extends ClassLoader {
    private String rootDir;

    public FileSystemClassLoader(String rootDir) {
        this.rootDir = rootDir;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = getClassData(name);
        if (classData == null) {
            throw new ClassNotFoundException();
        }
        else {
            //通过defineClass将字节码转化成为java.lang.class类实例
            return defineClass(name, classData, 0, classData.length);
        }
    }

    private byte[] getClassData(String className) {
        String path = classNameToPath(className);
        try {
            InputStream ins = new FileInputStream(path);
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int bufferSize = 4096;
            byte[] buffer = new byte[bufferSize];
            int bytesNumRead = 0;
            while ((bytesNumRead = ins.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesNumRead);
            }
            return baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String classNameToPath(String className) {
        return rootDir + File.separatorChar
                + className.replace('.', File.separatorChar) + ".class";
    }
}	
```

测试代码

```java
public class MyTest {
    public static void main(String[] args) {
        String classDataRootPath = "/home/helian/IdeaProjects/javaweb_01/fileoperator/target/classes";
        FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath);
        FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath);
//        String className = "com.lian.file.User";
        String className = "com.lian.file.Sample";
        System.out.println(fscl1);
        try {
            Class<?> class1 = fscl1.loadClass(className);
            Object obj1 = class1.newInstance();
            Class<?> class2 = fscl2.loadClass(className);
            Object obj2 = class2.newInstance();
            Method setSampleMethod = class1.getMethod("setSample", java.lang.Object.class);
            setSampleMethod.invoke(obj1, obj2);
            Class obj3 = ClassLoader.getSystemClassLoader().loadClass(className);
            setSampleMethod.invoke(obj1, obj3);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

